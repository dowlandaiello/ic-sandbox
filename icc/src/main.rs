use clap::Command;
use inetlib::bytecode2::{compilation as cc, vm::State};

mod cli;

use cli::*;

fn main() {
    tracing_subscriber::fmt::init();

    let cmd = clap::Command::new("dcc")
        .bin_name("dcc")
        .subcommand_required(true)
        .subcommand(
            Command::new("eval")
            .about("Parses an input .d file, reducing the input to completion and echoing the reduced expression, if not out file is specified")
            .arg(arg_in_file())
            .arg(arg_out_file_default("STDOUT".into())
        ))
        .subcommand(Command::new("compile")
            .about("Parses an input .d file, writing generated bytecode for reducing the program to a .dcode file of the same name")
            .arg(arg_in_file())
            .arg(arg_out_file_default("out.dcode".into())))
	.subcommand(Command::new("dump-compiled")
            .about("Parses an input .d file, writing generated bytecode for reducing the program to stdout")
            .arg(arg_in_file())
            .arg(arg_out_file_default("STDOUT".into())))
	.subcommand(Command::new("dump-compiled-pretty")
            .about("Parses an input .d file, writing generated human-readable bytecode for reducing the program to stdout")
            .arg(arg_in_file())
            .arg(arg_out_file_default("STDOUT".into())));

    let arg_matches = cmd.get_matches();
    match arg_matches.subcommand() {
        Some(("compile", arg_matches)) => {
            compile(arg_matches, |program| {
                bincode::serialize(&cc::compile(program).unwrap())
                    .expect("failed to serialize compiled program")
            });
        }
        Some(("dump-compiled", arg_matches)) => {
            transform_input_to_output_cli(arg_matches, |program| {
                serde_json::to_string_pretty(&cc::compile(program).unwrap())
                    .unwrap()
                    .into_bytes()
            });
        }
        Some(("dump-compiled-pretty", arg_matches)) => {
            transform_input_to_output_cli(arg_matches, |program| {
                cc::compile(program).unwrap().to_string().into_bytes()
            });
        }
        Some(("eval", arg_matches)) => {
            transform_input_to_output_cli(arg_matches, |program| {
                let bytecode = match cc::compile(program.clone()) {
                    Ok(bytecode) => bytecode,
                    Err(e) => {
                        panic!("compilation error {}", e);
                    }
                };

                let mut exec = State::new(bytecode, program.symbol_declarations_for);
                let results = exec.step_to_end().unwrap();

                results
                    .map(|n| n.to_string())
                    .collect::<Vec<_>>()
                    .join("\n")
                    .into_bytes()
            });
        }
        _ => unreachable!("clap should ensure we don't get here"),
    };
}
